###2.5 函数
>在Go语言中，函数的基本组成为：关键字`func`、函数名、参数列表、返回值、函数体和返回语句

###2.5.1 函数定义
```go
func Add(a, b int) (ret int, err error) {
	if a < 0 || b < 0 {
		err = errors.New("should be non-negative ")
		return
	}
	return a + b, nil
}
```
类型相同，可以合并；若只返回一个值，则可以写为
```go
func Add(a int, b int) int {
```
###2.5.2 函数调用
```go
import "package name"

import (
	"package name1"
	"package name2"
)
```
**小写字母开头的函数只在本包内可见，大写字母开头的函数才能被其他包使用，此规则适用于类型和变量**

###2.5.3 不定参数
>不定参数是指函数传入的参数个数为不定数量。为了做到这点，首先需要将函数定义为接受不定参数类型。

`fmt.Println()`等函数的视线严重依赖于语言的不定参数功能。合适的使用不定参数，可以让代码简单易用，尤其是输入输出类函数，比如日志函数等

######1.不定参数类型
```go
func main() {
	myfunc(2, 3, 4)
	myfunc(1, 3, 7, 13)
}
func myfunc(args ...int) {
	for _, arg := range args {
		fmt.Println(arg)
	}
}
```
**形如`...type`格式的类型职能作为函数的参数类型存在，并且必须是最后一个参数。它是一个语法糖（syntactic sugar），即这种语法对语言的功能并没有影响，但是更方便程序员使用。使用语法糖能够增加程序的可读性，从而减少程序出错的机会。**
>从内部实现机理来讲，类型`...type`本质上是一个数组切片，也就是`[]type`

######2.任何类型的不定参数
>如果希望传任意类型，可以指定类型为interface{}，如`fmt.Printf()`函数

```go
func Printf(format string, a ...interface{}) (n int, err error) {
	//...
}
```
>用`interface{}`传递任意类型数据是Go语言的惯例用法。使用`interface{}`仍然是类型安全的。

###2.5.5 函数匿名与闭包
>匿名函数是指不需要定义函数名的一种函数实现方式。由一个不带函数名的函数声明和函数体组成

######1.匿名函数
>在Go里，函数可以像普通变量一样被传递或使用，支持岁时在代码里定义匿名函数。

```go
f := func(x, y int) int {
		return x + y
	}(3, 5)
fmt.Println(f)
```
**匿名函数右花括号}后直接跟参数列表表示函数调用**

######2.闭包
* 基本概念
>闭包是可以包含自由（未绑定到特定对象）变量的代码块，这些变量不在这个代码块内或任何全局上下文中定义，而是在定义代码块的环境中定义。要执行的代码块（由于自由变量包含在代码块中，所以这些自由变量以及它们引用的对象没有被释放）为自由变量提供绑定的计算环境（作用域）

* 价值
>在于可以作为函数对象或者匿名函数，对于类型系统而言，这意味着不仅要表示数据还要表示代码。支持闭包的多数语言都将函数作为第一级对象，就是说这些函数可以存储到变量中作为参数传递给其他函数，最重要的是能够被函数动态创建和返回

* Go语言中的闭包
> Go语言中的闭包同样也会引用到函数外的变量。闭包的实现确保只要闭包还被使用，那么被闭包引用的变量会一直存在。

```go
var j int = 5
a := func() func() {
	var i int = 10
	return func() {
		fmt.Printf("i, j: %d ,%d \n", i, j)
	}
}()
a()
j *= 2
a()
```
i,  j : 10, 5
i,  j : 10, 10

变量a指向的闭包函数引用了局部变量i和j，i的值被隔离，在闭包外不能被修改，改变j的值以后，再次调用a，发现结果是修改过的值。

在变量a指向的闭包函数中，只有内部的匿名函数才能访问i，而无法通过其他途径访问到，因此确保了i的安全性。